## 2.1 UserDaoTest 다시 보기
### 2.1.1 테스트의 유용성

> - 자신이 만든 프로그램을 변경하였을 때 처음과 동일한 기능을 수행하는 보장해줄수 있는 방법에는 테스트를 통해 결과를 확인하는 것 외에는 없다.
> - 테스트란 결국 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서，만든 코드를 확신할 수 있게 해주는 작업이다.

### 2.1.2 UserDaoTest의 특징

![enter image description here](https://raw.githubusercontent.com/src8655/cafe24_6_2/master/1.%ED%86%A0%EB%B9%84%EC%9D%98%20%EC%8A%A4%ED%94%84%EB%A7%81%203.1/2%EC%9E%A5%20%ED%85%8C%EC%8A%A4%ED%8A%B8/1~3%20USERDAOTEST%20%EB%8B%A4%EC%8B%9C%20%EB%B3%B4%EA%B8%B0%2C%20%EA%B0%9C%EC%84%A0%2C%20JUNIT/TestByMain.PNG)

- 이 테스트 코드의 내용
> - 자바에서 가장 손쉽게 실행 가능한 main() 메소드를 이용한다.
> - 테스트할 대상인 UserDao의 오브젝트를 가져와 메소드를 호출한다.
> - 테스트에 사용할 입력 값(User 오브젝트)을 직접 코드에서 만들어 넣어준다.
> - 테스트의 결과를 콘솔에 출력해준다.
> - 각 단계의 작업이 에러 없이 끝나면 콘솔에 성공 메시지로 출력해준다.

#### 웹을 통한 DAO 테스트 방법의 문제점

> - DAO뿐만 아니라 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다.
> - 테스트를 하는 중에 에러가 나거나 테스트가 실패했다면, 어디에서 문제가 발생했는지를 찾아내야 한다.
> - 오류가 있을 때 빠르고 정확하게 대응하기가 힘들다는 문제가 있다.

#### 작은 단위의 테스트

> - 작은 단위의 코드에 대해 태스트를 수행한 것을 단위 테스트(unit test)라고 한다.
> - 단위란 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다.
> - 일반적으로 단위는 작을수록 좋다.
> - 단위 테스트를 하는 이유는 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서다.

#### 자동수행 테스트 코드

> - 테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다.
> - 애플리케이션을 구성하는 클래스 안에 테스트 코드를 포함시키는 것보다는 별도로 테스트용 클래스를 만들어서 테스트 코드를 넣는 편이 낫다.
> - 지동으로 수행되는 테스트의 장점은 지주 반복할 수 있다는 것이다.

#### 지속적인 개선과 점진적인 개발을 위한 테스트

> - 테스트가 없었다면, 다양한 방법을 동원해서 코드를 수정하고 설계를 개선해나기는 과정이 그다지 미덥지 않을 수도 있다.
> - 작은 단계를 거치는 동안 테스트를 수행해서 확신을 가지고 코드를 변경해갔기 때문에 전체적으로 코드를 개선하는 작업에 속도가 붙고 더 쉬워졌을 수도 있다.
> - 기능을 추가하려고 할 때도 미리 만들어둔 테스트 코드는 유용하게 쓰일 수 있다.

### 2.1.3 UserDaoTest의 문제점

#### 수동 확인 작업의 번거로움

> - UserDaoTest는 테스트를 수행히는 과정과 입력 데이터의 준비를 모두 자동으로 진행하도록 만들어졌다. 하지만 여전히 사람의 눈으로 확인하는 과정이 필요하다.
> - 작은 차이는 미처 발견하지 못하고 넘어가는 실수를 할 가능성도 있다.

#### 실행 작업의 번거로웅

> - 만약 DAO가 수백 개가 되고 그에 대한 main() 메소드도 그만큼 만들어진다면. 전체 기능을 테스트해보기 위해 main() 메소드를 수백 번 실행하는 수고가 필요하다.
> - 좀 더 편리하고 체계적으로 테스트를 실행하고 그 결과를 확인하는 방법이 절실히 필요하다.



## 2.2 UserDaoTest 개선

### 2.2.1 테스트 검증의 자동화

> - 모든 태스트는 성공과 실패의 두 가지 결괴를 가질 수 있다.
> - 테스트 중에 에러가 발생하는 것은 쉽게 확인이 가능하다.
> - 하지만 테스트가 실패하는 것은 별도의 확인 작업과 그 결과가 있어야만 알 수 었다.

{BeforeTestCode}
{AfterTestCode}


> - 이 테스트는 UserDao의 두 가지 기능이 정상적으로 동작하는지를 언제든지 손쉽게 확인할 수 있게 해준다. 따라서 이 코드의 동작에 영향을 미칠 수 있는 어떤 변화라도 생기면 언제든 다시 실행해볼 수 있다.
> - 개발 과정에서, 또는 유지보수를 하면서 기존 애플리케이션 코드에 수정을 할 때 미음의 평안을 얻고, 자신이 만지는 코드에 대해 항상 자신감을 가질 수 있으며, 새로 도입한 기술의 적용에 문제가 없는지 확인할 수 있는 가장 좋은 방법은 빠르게 실행 기능하고 스스로 테스트 수행과 기대하는 결과에 대한 확인까지 해주는 코드로 된 자동화된 테스트를 만들어두는 것이다.


### 2.2.2 테스트의 효율적인 수행과 결과 관리

> - 좀 더 편리하게 테스트를 수행하고 편리하게 결과를 확인하려면 단순한 main() 메소드로는 한계가 있다.
> - 일정한 패턴을 가진 테스트를 만들 수 있고, 많은 테스트를 간단히 실행시킬 수 있으며, 테스트 결과를 종합해서 볼 수 있고 테스트가 실패한 곳을 빠르게 찾을 수 있는 기능을 갖춘 테스트 지원 도구와 그에 맞는 테스트 작성 방법이 필요하다.
> - 자바 테스팅 프레임워크라고 불리는 JUnit은 자바로 단위 테스트를 만들 때 유용하게 쓸 수 있다.


#### JUnit 테스트로 전환

> - JUnit은 프레임워크다.
> - 프레임워크에서 동작하는 코드는 main() 메소드도 필요 없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.

#### 테스트 메소드 전환

- JUnit 프레임워크에서 동작하도록 테스트 메소드를 재구성
{ChangeJUnit}


#### 검증 코드 전환

> - assertThat() 메소드는 첫 번째 파라미터의 값을 뒤에 나오는 매처(matcher)라고 불리는 조건으로 비교해서 일치하면 다옴으로 넘어가고， 아니면 테스트가 실패하도록 만들어준다.
> - JUnit은 예외가 발생하거나 assertThat() 에서 실패하지 않고 테스트 메소드의 실행이 완료되면 테스트가 성공했다고 인식한다.

{JUnitUserDaoTest}

#### JUnit 테스트 실행

> - JUnit 프레임워크도 자바 코드로 만들어진 프로그램이므로 어디선가 한 번은 JUnit 프레임워크를 시작시켜 줘야 한다.
> - 어디에든 main() 메소드를 하나 추가하고, 그 안에 JUnitCore 클래스의 main 메소드를 호출해주는 간단한 코드를 넣어주면 된다. 메소드 파라미터에는 @Test 테스트 메소드를 가진 클래스의 이름을 넣어준다.

{JunitMain}

> - 테스트가 실패하면 OK 대신 FAILURES!! 라는 내용이 출력되고, 총 수행한 테스트 중에서 몇 개의 테스트가 실패했는지 보여준다.
> - 테스트 수행 중에 일반 예외가 발생한 경우에도 마찬가지로 테스트 수행은 중단되고 테스트는 실패한다.


## 2.3 개발자를 위한 테스팅 프레임워크 JUnit

> - JUnit은 사실상 자바의 표준 테스팅 프레임워크라고 불릴 만큼 폭넓게 사용되고 있다.
> - 스프링을 학습하고 제대로 활용하려면 최소한의 JUnit 테스트 작성 방법과 실행 방법은 알고 있어야 한다.
> - 대부분의 자바 IDE는 JUnit 테스트를 손쉽게 실행할 수 있는 JUnit 테스트 지원 기능을 내장하고 있어서 더욱 편리하게 JUnit 테스트를 만들고 활용할 수 있게 해준다.


### 2.3.1 JUnit 테스트 실행 방법

#### IDE
> - 대부분의 자바 개발자가 사용하고 있는 사실상의 표준 자바 IDE인 이클립스는 오래전부터 JUnit 테스트를 지원하는 기능을 제공하고 있다.

{EclipseJUnit}

> - 이 뷰에서 테스트의 총 수행시간, 실행한 테스트의 수, 태스트 에러의 수, 테스트 실패의 수를 확인할 수 있다.
> - 테스트가 실패해서 코드를 수정한 뒤, 다시 테스트를 실행하려면 JUnit 테스트 뷰의 녹색 Rerun Test 버튼을 클릭하면 된다.
> - JUnit 테스트의 실행과 그 결과를 확인하는 방법이 매우 간단하고 직관적이며 소스와 긴밀하게 연동돼서 결과를 볼 수 있기 때문에， 개발 중에 테스트를 실행하고자 할 때는 이클립스 같은 IDE의 지원을 받는 것이 가장 편리하다.


#### 빌드 툴

> - 프로젝트의 빌드를 위해 ANT나 메이븐(Maven) 같은 빌드 툴과 스크립트를 사용하고 있다면, 빌드 툴에서 제공하는 JUnit 플러그인이나 태스크를 이용해 JUnit 테스트를 실행할 수 있다.
> - 여러 개발자가 만든 코드를 모두 통합해서 테스트를 수행해야 할 때도 있다. 이런 경우에는 서버에서 모든 코드를 가져와 통합하고 빌드한 뒤에 테스트를 수행하는 것이 좋다.


### 2.3.2 테스트 결과의 일관성

> - 테스트가 외부 상태에 따라 성공하기도 하고 실패하기도 한다.
> - 반복적으로 테스트를 했을 때 테스트가 실패하기도 하고 성공하기도 한다면 이는 좋은 테스트라고 할 수가 없다. 코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.


### 2.3.3 포괄적인 테스트

> - 미처 생각하지 못한 문제가 숨어 있을지도 모르니 더 꼼꼼한 테스트를 해보는 것이 좋은 자세다.
> - 테스트를 안 만드는 것도 위험한 일이지만, 성의 없이 테스트를 만드는 바람에 문제가 있는 코드인데도 테스트가 성공하게 만드는 건 더 위험하다. 특히 한 가지 결과만 검증하고 마는 것은 상당히 위험하다.


#### 예외조건에 대한 테스트

> - 일반적으로는 테스트 중에 예외가 던져지면 테스트 메소드의 실행은 중단되고 태스트는 실패한다.
> - 예외 발생 여부는 메소드를 실행해서 리턴 값을 비교하는 방법으로 확인할 수 없다. 즉 assertThat() 메소드로는 검증이불가능하다.
> - 이런 경우를 위해 JUnit은 예외조건 태스트를 위한 특별한 방법을 제공해준다.

{JUnitException}

> - @Test에 expected를 추가해놓으면 보통의 테스트와는 반대로, 정상적으로 테스트 메소드를 마치면 테스트가 실패하고. expected에서 지정한 예외가 던져지면 테스트가 성공한다. 예외가 반드시 발생해야 하는 경우를 테스트하고 싶을 때 유용하게 쓸 수 있다.


#### 포괄적인 테스트

> - 종종 단순하고 간단한 테스트가 치명적인 실수를 피할 수 있게 해주기도 한다.
> - 개발자가 테스트를 직접 만들 때 자주 하는 실수가 하나 있다. 바로 성공히는 테스트만 골라서 만드는 것이다.
> - 그래서 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다.



### 2.3.4 테스트가 이끄는 개발

#### 기능 설계를 위한 테스트

{GetUserFailure}

> - 기능설계, 구현, 테스트라는 일반적인 개발 흐름의 기능설계에 해당하는 부분을 이 테스트 코드가 일부분 담당하고 있다고 볼 수도 있다.
> - 만약 테스트가 실패하면 이때는 설계한 대로 코드가 만들어지지 않았음을 바로 알 수 있다. 그리고 문제가 되는 부분이 무엇인지에 대한 정보도 테스트 결과를 통해 얻을 수 있다.
> - 테스트가 성공한다면 그 순간 코드 구현과 테스트라는 두 가지 작업이 동시에 끝나는 것이다.


#### 테스트 주도 개발

> - 만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고 태스트를 성공하게 해주는 코드를 작성히는 방식의 개발 방법을 테스트 주도 개발(TDD)라고 한다.
> - TDD는 개발자가 테스트를 만들어가며 개발하는 방법이 주는 장점을 극대화한 방법이라고 볼 수 있다.
> - TDD는 아예 테스트를 먼저 만들고 그 테스트가 성공하도록 하는 코드만 만드는 식으로 진행하기 때문에 테스트를 빼먹지 않고 꼼꼼하게 만들어낼 수 있다.
> - TDD에서는 테스트 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 가능한 한 짧게 가져가도록 권장한다.
> - TDD를 하면 자연스럽게 단위 테스트를 만들 수 있다.
> - TDD의 장점 중 하나는 코드를 만들어 테스트를 실행하는 그 사이의 간격이 매우 짧다는 점이다.
> - 테스트는 코드를 작성한 후에 기능한 빨리 실행할 수 있어야 한다.


### 2.3.5 테스트 코드 개선

- JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다.
> 1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
> 2. 테스트 클래스의 오브젝트를 하나 만든다.
> 3. @Before가 붙은 메소드가 있으면 실행한다.
> 4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
> 5. @After가 붙은 메소드가 있으면 실행한다.
> 6. 나머지 테스트 메소드에 대해 2 ~ 5 번을 반복한다.
> 7. 모든 테스트의 결과를 종합해서 돌려준다.

{JUnitProcess}


#### 픽스처

> - 테스트를 수행히는 데 필요한 정보나 오브젝트를 픽스처(fixture)라고 한다.
> - 일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메소드를 이용해 생성해두면 편리하다.
> - 픽스처 생성 로직이 흩어져 있는 것보다는 모여 있는 편이 낫다.
