[toc]

# CH2. 테스트

## 2.4 스프링 테스트 적용

> 테스트는 가능한 한 독립적으로 매번 새로운 오브젝트를 만들어서 사용히는 것이 원 
> 칙이다. 하지만 애플리케이션 컨텍스트처럼 생성에 많은 시간과 자원이 소모되는 경우 에는 태스트 전체가 공유하는 오브젝트를 만들기도 한다.  

- 테스트 메소드 마다 매번 애플리케이션 컨텍스트를 생성한다면, 빈이 많아지고 복잡해지면 애플리케이션 컨텍스트 생성에 상당한 시간이 걸릴 수도 있다

### 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리

> 스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공하는데, 이를 이용하면 애노테이션 설정으로 테스트에서 필요로 하는 애플리케이션 컨텍스트를 만들어서 모든 테스트가 공유할 수 있다.

- ApplicationContext타입의 인스턴스 변수를 선언하고 @Autowired 애노테이션을 붙여준다.

- 클래스 레벨에 @RunWith(SpringlUnit4ClassRunner.class) 와

  @ContextConfiguration(locations="설정파일 위치") 를 붙여준다.

  - SpringlUnit4ClassRunner :  JUnit이 테스트를 진행히는 중에 태스트가 사용할 애플리케이션 컨텍 스트를 만들고 관리
  - @ContextConfiguration은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정

=> 테스트 오브젝트가 만들어 질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해준다. 

#### 테스트 클래스의 컨텍스트 공유

> 여러 개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 태스트 클래스 사이에서도 애플라케이션 컨텍스트를 공유하게 해준다. 

![](./image/01.png)

- 설정파일의 종류만큼 애플리케이션 컨텍스트를 만들고, 같은 설정파일을 지정한 테스트에서는 이를 공유

#### @Autowired

- @Autowired가 붙은 인스턴스 변수가 있으면 태스트 컨텍스트 프레임워크는 변수 타입 
  과 일치하는 컨텍스트 내의 빈을 찾고, 타입이 일치하는 빈이 있으면 인스턴스 변수 
  에 주입해준다. 일반적으로는 주입을 위해서는 생성자나 수정자 메소드 같은 메소드가 펼요하지만， 이 경우에는 메소드가 없어도 주입이 가능하다. 
- 또 별도의 DI 설정 없이 필드의 타입정보를 이용해 빈을 자동으로 가져올 수 있는데 이런 방법을 타입에 의한 자 동와이어령이라고한다. 
- ApplicationContext라는 타입의 변수에 @Autowired 를 붙였는데 애플리케이션 컨텍스트가 DI됐다. 이는 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록하기 때문이다.
- @Autowired는 같은 타입의 빈이 두 개 이상 있는 경우에는 타입만으로는 어떤 빈을 가져올지 결정할 수 없다. 이런 경우에는 변수의 이름과 같은 이름의 빈이 있는지 확인한다. 변수 이름으로도 빈을 찾을 수 없는 경우에는 예외가 발생한다. 
- 꼭 필요하지 않다면 테스트에서도 가능한 한 인터페이스를 사용해서 느슨하게 연결하는 편이 좋다.



### 2.4.2 DI와 테스트

UserDao와 DB 커넥션 생성 클래스 사이에는 DataSource라는 인터페이스를 둔 것 처럼 인터페이스를 두고 DI를 적용해야 하는 이유

> 1. 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문이다. 당장에는 클래스를 바꿔서 사용할 계획이 전혀 없더라도， 언젠가 변경이 펼요한 상황이 닥쳤을 때 수정에 들어가는 시간과 비용의 부담을 줄여줄 
>    수 있다
> 2. 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI 를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있다. ( ex] 1장에서 DB커넥션 개수를 카운팅하는 부가기능 )
> 3. 테스트 때문이다. DI는 태스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하 는 데 중요한 역할을 한다. 

#### 테스트 코드에 의한 DI

> DI는 스프링 컨테이너에서만 사용할 수 있는 작업이 아니다. 생성자 메소드, 수정자 메소드 등 평범한 자바 메소드를 통해 의존관계 주입을 할 수 있으므로 테스트 코드에서도 얼마든지 DI를 해줄 수 있다.

- 테스트 코드시에는 테스트용 DB에 연결해주는 DataSource를 만들고 싶은 경우)

![](./image/02.png)

![](./image/03.png)

- 이 방식은 이미 애플라케이션 컨텍스트에서 applicationContext.xml 파일의 설정정보를 따라 구성한 오브젝트를 가져와 의존관계 를 강제로 변경한다.
- 스프링 테스트 컨텍스트 프레임워크를 적용했다면 애플리케이션 컨텍스트는 테스트 중에 딱 한 개만 만들어지고 모든 테스트에서 공유해서 사용한다.
- 나머지 모든 테스트를 수행 하는 동안 변경된 애플리케이션 컨텍스트가 계속 사용될 것이므로 이는 별로 바람직하지 못하다.
- 그래서 UserDaoTest에는 @DirtiesContext라는 애노테이션을 추가해준다. 이 애노태이션은 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 태스트에서 애플리 케이션 컨텍스트의 상태를 변경한다는 것을 알려준다. 
- 테스트 컨텍스트는 이 애노테이션이 붙은 테스트 클래스에는 애플리케이션 컨텍스트 공유를 허용하지 않는다. 테스트 메소드를 수행하고 나면 매번 새로운 애플리케이션 컨텍스트를 만들어서 다음 테스트가 사용하게 해준다. (메소드 레벨에도 적용 가능)

#### 테스트를 위한 별도의 DI 설정

> 테스트 코드에서 수동으로 DI하는 방법은 단점이 더 많다. ( 코드가 많아짐, 매번 애플리케이션 컨텍스트를 새로 만듦) DI의 장점을 살려 DAO가 테스트에서만 다른 DataSource를 사용하게 할 수 있는 방법이 필요하다. 

==> 두 가지 종류의 설정파일을 만들어서 하나에는 서버에서 운영용으로 사용할 DataSource를 빈으로 등록해두고，다른 하나에는 테스트에 적합하게 준비된 DB를 사용히는 가벼운 DataSource가 빈으로 등록되게 만든다. 그리고 테스트에서는 항상 테스트 전용 설정파일만 사용하게 해준다.

![](./image/04.png)



#### 컨테이너 없는 DI 테스트

> DI를 테스트에 이용하는 방법 중 스프링 컨테이너를 사용하지 않고 테스트를 만드는 방법도 있다.

- @RunWith를 사용해서 스프링 테스트 컨텍스트의 프레임워크를 적용하지도 않고,
- @Autowired를 사용해서 컨테이너에 의존하지도  않고,
- 테스트 코드에서 직접 오브젝트를 만들고 DI 해서 사용

![](./image/05.png)



#### DI를 이용한 테스트 방법 선택

> 항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려하자. 이 방법이 태스트 수행 속도가 가장 빠르고 태스트 자체가 간결하다. 
>
> 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 태스트해야 할 경우는 스프링의 설정을 이용한 DI 방식의 태스트를 이용하면 편리하다. 테스트에서 애플리케이션 컨텍스트를 사용히는 경우에는 테스트 전용 설정따일을 따로 만들어 사용하는 편이 좋다.
>
> 테스트 설정을 따로 만들었다고 하더라도 때로는 예외적인 의존관계를 강제로 구성해야 할 경우는 컨텍스트에서 DI 받은 오브젝트에 다시 테스트 코드로 수동 DI 해서 테스트하는 방법을 사용하면 된다. 테스트 메소드나 클래스에 @DirtiesContext 애노테이션을 붙이는 것을 잊지 말자. 

## 2.5 학습테스트로 배우는 스프링

> 학습테스트 :  자신이 만들지 않은 프레임워크나 다른 
> 개발팀에서 만들어서 제공한 라이브러리 등에 대해서 테스트를 작성하는 것
>
> 학습테스트의 목적 :  자신이 시용할 API나 프레임워크의 기능을 테스트로 보면서 
> 사용 방법을 익히려는 것

### 2.5.1 학습테스트의 장점

- 다양한 조건에 따른 기능을 손쉽게 확인해불 수 있다 
  - 예제를 만들면 서 학습하는 것은 수동 테스트와 성격이 비슷하다. 다양한 조건에 따라 어떻게 기능이 다르게 동작하는지 확인해보려면 수동으로 값을 입력하거나 코드를 계속 수정해가며 예제를 다시 실행해야 한다. 반면에 학습 테스트는 자동화된 테스트 코드로 만들어지기 때문에 다양한 조건에 따라 기능이 어떻게 통작하는지 빠르게 확인할 수 있다. 
- 학습 테스트 코드툴 개발 중에 참고할 수 있다 
  - 수동으로 예제를 만드는 방법은 코드를 계속 수정해가면서 기능을 확인해보기 때문 
    에 결국 최종 수정한 예제 코드만 남아 있다. 
  - 반면에 학습 테스트는 다양한 기능과 조건에 대한 테스트 코드를 개별적으로 만들고 남겨둘 수 있다. 이렇게 테스트로 새로운 기술의 다양한 기능을 사용하는 코드를 만들어두면 실제 개발에서 샘플 코드로 참고할 수 있다.
- 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다 
  - 요즘은 모든 제품이 매우 빠르게 업데이트된다. 새로운 버전으로 업그레이드를 할 때 API 사용법에 미묘한 변화가 생긴다거나， 기존에는 잘 동작하던 기능에 문제가 발생할 수도 있다.
  - 학습 테스트에 애플리케이션에서 자주 사용히는 기능에 대한 테스트를 만들어놓았다면 새로운 버전의 프레임워크나 제품을 학습 테스트에만 먼저 적용해본다. 
  - 기존에 사용했던 API나 기능에 변화가 있거나 업데이트된 제품 에 버그가 있다면，학습 테스트를 통해 미리 확인할 수가 있다. 
- 테스트 작성에 대한 좋은 훈련이 된다.
  - 개발자가 테스트를 작성하는 데 아직 충분히 훈련되어 있지 않거나 부담을 갖고 있다면， 학습 테스트를 작성해보면서 테스트 코드 작성을 연습할 수 있다. 
  - 프레임워크의 학습 테스트는 한두 가지 간단한 기능에만 초점을 맞추면 되기 때문에 테스트도 대체로 단순하다. 따라서 애플리케이션 개발 중에 작성하는 테스트보다는 한결 작성하기가 수월하고 부담도 적다. 
  - 새로운 테스트 방법을 연구히는 데도 도움 이 된다. 
- 새로운 기술을 공부하는 과정이 즐거워진다



> 학습 테스트는 당장 적용할 일부 기능의 사용법을 익히기 위해서만이 아니라 새로운 
> 프레임워크나 기술을 전반적으로 공부히는 과정에서도 유용하다.  
>
> 스프링 학습 태스트를 만들 때 참고할 수 있는 가장 좋은 소스는 바로 스프링 자신
> 에 대한 테스트 코드다.   스프링 배포판의 압축을 풀어보면 프레입워크 소스코드와 함께 태스트 코드도 발견할 수 있을 것이다

### 2.5.2 학습 테스트 예제

#### JUnit 테스트 오브젝트 테스트

- JUnit은 테스트 메소드를 수행할 때마다 정말 새로운 오브젝트가 만들어 지는지에 대한 테스트

![](./image/06.png)

![](./image/07.png)

[매번 새로운 테스트 오브젝트를 만드는지 확인하는 방법]

1. 스태틱 변수로 테스트 오브젝트를 저장할 수 있는 컬렉션을 만든다.
2. 테스트 마다 현재 테스트 오브젝트가 컬렉션에 이미 등록되어 있는지 확인하고, 없으면 자기 자신을 추가한다. 
3. 반복

#### 스프링 테스트 컨텍스트 테스트

[테스트 메소드에서 매번 동일한 애플리케이션 컨텍스트가 context 변수에 주입돼는지 확인]

p203 리스트 2-26참고

1. context를 저장해둘 스태틱 변수 contextObject가 null인지 확인
2. 첫 번째 테스트라면 null, 그리고 contextObject에 현재 context를 저장
3. 다음부터는 현재의 context와 contextObject 비교
4. 한번이라도 다른 오브젝트가 나오면 테스트는 실패



### 2.5.3 버그 테스트

> 버그 테스트bug test란 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트 \
>
> 버그 테스트는 일단 실패하도록 만들어야 한다. 버그가 원인이 되서 테스트가 실패 
> 하는 코드를 만드는 것이다. 그러고 나서 버그 테스트가 성공할 수 있도록 애플리케이 션 코드를 수정한다. 태스트가 성공하면 버그는 해결된 것이다. 

- 버그 태스트의 펼요성과 장점
  - 테스트의 완성도를 높여준다 
  - 버그의 내용을 명확하게 분석하게 해준다 
  - 기술적인 문제를 해결하는 데 도움이 된다 

